// Generated by svd_parser.rb. Dont't edit please.
#ifndef <%= include_guard_name %>
#define <%= include_guard_name %>

#include <igb_stm32/base.hpp>
#include <array>
#include <optional>

<% @svd_parser.parsed.keys.each do |group_name| %>
#define STM32_PERIPHGRP_<%= group_name.upcase %>_EXISTS 1
<% @svd_parser.parsed[group_name].keys.each do |periph_name| %>
<%   next if include_black_list?(periph_name) %>
#define STM32_PERIPH_<%= periph_name.upcase %>_EXISTS 1
<% end %>
<% end %>
<% if @svd_parser.parsed[:GPIO].first.last[:registers][:BRR] %>
#define STM32_PERIPH_GPIO_REG_BRR_EXISTS 1
<% end %>

namespace igb {
namespace stm32 {

enum class PeriphGroupType : uint16_t {
<% first = true %>
<% @cpp_structs.each do |group_name, structs| %>
<%  next if !structs || structs.empty? %>
  <%= group_name.downcase %><%= (first = false) or ' = 0' if first %>,
<% end %>
};

enum class PeriphType : uint16_t {
<% first = true %>
<% @cpp_structs.each do |group_name, structs| %>
<%#<%  next if !structs || structs.empty? +|%>
<%  structs.each do |struct| %>
  <%= struct[:periph].downcase %><%= (first = false) or ' = 0' if first %>,
<%  end %>
<% end %>
};

<% @cpp_structs.each do |group_name, structs| %>
<%  next if !structs || structs.empty? %>
<%  next if schema.dig(group_name.to_sym, :singleton) %>
enum class <%= group_name.capitalize %>Type : uint8_t {
<%  first = true %>
<%  structs.each do |struct| %>
  <%= struct[:periph].downcase %><%= (first = false) or ' = 0' if first %>,
<%  end %>
};
constexpr static uint8_t to_idx(<%= group_name.capitalize %>Type type) {
  switch (type) {
<%  structs.each_with_index do |struct, idx| %>
    case <%= group_name.capitalize %>Type::<%= struct[:periph].downcase %>:
      return <%= idx %>;
      break;
<%  end %>
  }
  return 0;
}
<% end %>

enum class GpioPinType : uint8_t {
<% @cpp_structs[:GPIO].each do |struct| %>
<%  (0..15).each do |id| %>
  p<%= struct[:periph][-1].downcase %><%= id %> = (<%= struct[:periph][-1].ord - 'A'.ord %> << 4) | <%= id %>,
<%  end %>
<% end %>
};

constexpr static GpioType extract_gpio_type(GpioPinType pin_type) {
  switch (pin_type) {
<% @cpp_structs[:GPIO].each do |struct| %>
<%  (0..15).each do |id| %>
    case GpioPinType::p<%= struct[:periph][-1].downcase %><%= id %>:
<%  end %>
      return GpioType::<%= struct[:periph].downcase %>;
      [[fallthrough]];
<% end %>
    default:
      break;
  }
  return GpioType::gpioa; // never reach
}

constexpr static uint8_t extract_pin_idx(GpioPinType pin_type) {
  switch (pin_type) {
<% @cpp_structs[:GPIO].each do |struct| %>
<%  (0..15).each do |id| %>
    case GpioPinType::p<%= struct[:periph][-1].downcase %><%= id %>:
      return <%= id %>;
<%  end %>
<% end %>
    default:
      break;
  }
  return 0; // never reach
}

enum class BusType : uint8_t {
<% @bus_names.each_with_index do |bus_name, i| %>
  <%= bus_name.downcase %><%= ' = 0' if i == 0 %>,
<% end %>
};

const std::array<__IO uint32_t*, <%= @bus_names.size %>> STM32_BUS_TO_ENR_ADDRESS = {
<% @bus_names.each_with_index do |bus_name, i| %>
  &(RCC-><%= bus_name %>ENR),
<% end %>
};

const std::array<__IO uint32_t*, <%= @bus_names.size %>> STM32_BUS_TO_RSTR_ADDRESS = {
<% @bus_names.each_with_index do |bus_name, i| %>
  &(RCC-><%= bus_name %>RSTR),
<% end %>
};

#include <igb_stm32/base/_info.hpp>

constexpr struct PeriphInfo {
<% @cpp_structs.each do |group_name, structs| %>
<% next if !structs || structs.empty? %>
<%  if schema.dig(group_name.to_sym, :singleton) %>
  const <%= schema[group_name.to_sym][:name] %> <%= group_name.downcase %> {
    .periph_type = PeriphType::<%= structs.first[:periph].downcase %>,
<%    structs.first[:attrs].each do |key, value| %>
    .<%= key %> = <%= value[:value] %>,
<%    end  %>
<%    if bus = structs.first[:bus] %>
    .bus = PeriphBusInfo { BusType::<%= bus[:name].downcase %>, (uint32_t)1 << <%= bus[:bit_offset] %>},
<%    end  %>
  };
<%  else %>
  const std::array<<%= schema[group_name.to_sym][:name] %>, <%= structs.size %>> <%= group_name.downcase %> {
<%    structs.each do |struct| %>
    <%= schema[group_name.to_sym][:name] %> {
      .periph_type = PeriphType::<%= struct[:periph].downcase %>,
<%      struct[:attrs].each do |key, value| %>
      .<%= key %> = <%= value[:value] %>,
<%      end %>
<%      if bus = struct[:bus] %>
      .bus = PeriphBusInfo { BusType::<%= bus[:name].downcase %>, (uint32_t)1 << <%= bus[:bit_offset] %>},
<%      end  %>
<%      if group_name.to_sym == :DMA %>
      .channels = {
<%        (1..8).each do |i| %>
  <%          dma_ch_exists = !@svd_parser.search_interrupts(/\A#{struct[:periph]}_CH#{i}(_|\z)/).empty? %>
        DmaChannelInfo {
          .exists = <%= dma_ch_exists ? 'true' : 'false' %>,
          .p_dma_channel = <%= dma_ch_exists ? "#{struct[:periph]}_Channel#{i}" : '(DMA_Channel_TypeDef*)0' %>,
          .addr = <%= dma_ch_exists ? "#{struct[:periph]}_Channel#{i}_BASE" : '0' %>,
          .irqn = <%= fetch_dma_irqn_name(struct[:periph], i) || '(IRQn_Type)0' %>
        },
<%        end %>
      },
<%      end  %>
    },
<%    end %>
  };
<%  end %>
<% end %>
} STM32_PERIPH_INFO;

enum class GpioAf : uint8_t {
  af0 = 0,
<% (1 .. @df_parser.af_max_idx).each do |idx| %>
  af<%= idx %>,
<% end %>
};

constexpr static std::optional<GpioAf> get_af_idx(PeriphType periph_type, GpioPinType gpio_pin) {
  switch (gpio_pin) {
<% @df_parser.parsed[:gpio].each do |port_name, port| %>
<%   next if include_black_list?("GPIO#{port_name.upcase}") %>
<%  port.each do |pin, signals| %>
<%    next if signals.empty? || !signals.any?{|sig| sig[:af]}%>
    case GpioPinType::p<%= port_name %><%= pin %>:
      switch (periph_type) {
<%    signals.select {|sig| sig[:af]}.uniq {|sig| "#{sig[:driver]}#{sig[:instance]}" }.each do |sig| %>
<%      periph_name = "#{sig[:driver]}#{sig[:instance]}" %>
<%      next unless @periph_names.include?(periph_name.upcase) %>
        case PeriphType::<%= periph_name %>:
          return GpioAf::af<%= sig[:af] %>;
<%    end %>
        default:
          break;
      }
      break;
<%  end %>
<% end %>
    default:
      break;
  }
  return std::nullopt;
}

template<typename T>
constexpr static std::optional<PeriphType> as_periph_type(T type) {
  return std::nullopt;
}

<% @cpp_structs.each do |group_name, structs| %>
<%  next if !structs || structs.empty? %>
<%  next if schema.dig(group_name.to_sym, :singleton) %>
template<>
constexpr std::optional<PeriphType> as_periph_type(<%= group_name.capitalize %>Type type) {
  switch (type) {
<%  structs.each do |struct| %>
    case <%= group_name.capitalize %>Type::<%= struct[:periph].downcase %>:
      return PeriphType::<%= struct[:periph].downcase %>;
<%  end %>
  }
  return std::nullopt;
}
<% end %>

}
}

#endif /* <%= include_guard_name %> */
